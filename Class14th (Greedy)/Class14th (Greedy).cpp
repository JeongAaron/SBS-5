#include <iostream>

using namespace std;

const int& Greedy(int n)
{
	int a = 0, b = 0, c = 0, d = 0, e = 0;
	int count = 0;
	while (n >= 10)
	{
		if (n >= 1000)
		{
			n -= 1000;
			count++;
			a++;
		}
		else if (n >= 500)
		{
			n -= 500;
			count++;
			b++;
		}
		else if (n >= 100)
		{
			n -= 100;
			count++;
			c++;
		}
		else if (n >= 50)
		{
			n -= 50;
			count++;
			d++;
		}
		else if (n >= 10)
		{
			n -= 10;
			count++;
			e++;
		}
	}
	return count;
}

int main()
{
#pragma region 탐욕법

	//	최적의 해를 구하는 데에 사용되는 근사적인 방법으로 여러 경우 중 하나를 검색해야 할 때 마다
	//	그 수간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답을 구하는 알고리즘

	//	1. 탐욕 선택 속성
	//	각 단계에서 '최적의 선택'을 했을 때 전체 문제에 대한 최적의 해를 구할 수 있는 경우

	//	2. 최적 부분 구조
	//	전체 문제의 최적의 해가 '부분 문제의 초적의 해로 구성'될 수 있는 경우


	//	탐욕 알고리즘으로 문제를 해결하는 방법

	//	1. 선택 절차(Selection  Prucedure)
	//	   현재 상태에서의 최선의 해를 선택

	//	2. 적절성 검사(Feasibility Check)
	//     선택된 해가 문제의 조건을 만족하는지 검사

	//	3. 해답 검사(Solution Check)
	//     원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아감

	//	그리디 알고리즘 단계

	//	1. 문제의 최적 부분 구조를 결정

	//	2. 문제의 구조에 맞게 선택 절차를 정의

	//	3. 선택 절차에 따라 선택을 수행

	//	4. 선택된 해가 문제의 조건을 만족하는 지 검사

	//	5. 조건을 만족하지 않으면 해당 해를 제외

	//	6. 모든 선택이 완료되면 해답을 검사

	//	7. 조건을 만족하지 않으면 해답으로 인정되지 않는다

	cout << Greedy(1370) << endl;
#pragma endregion

}
